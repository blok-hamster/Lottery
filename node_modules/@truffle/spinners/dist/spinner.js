"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Spinner = void 0;
const spinnies_1 = __importDefault(require("spinnies"));
const spinnies = new spinnies_1.default();
class Spinner {
    constructor(name, optionsOrText) {
        this.name = name;
        const options = typeof optionsOrText === "string"
            ? { text: optionsOrText }
            : optionsOrText;
        if (options.text === undefined) {
            throw new Error("Spinner text cannot be undefined");
        }
        spinnies.add(this.name, options);
    }
    /**
     * Stops all spinners
     * @param status the terminal state of the spinners that have been stopped (one of "stopped", "succeed", or "fail").
     */
    static stopAll(status) {
        spinnies.stopAll(status);
    }
    /**
     * @returns false if all spinners have succeeded, failed or have been stopped
     */
    static hasActiveSpinners() {
        return spinnies.hasActiveSpinners();
    }
    /**
     * Removes this spinner from display. After this method is called, other modifications to this spinner object have no effect.
     */
    remove() {
        if (!spinnies.pick(this.name)) {
            return;
        }
        spinnies.remove(this.name);
        spinnies.checkIfActiveSpinners();
    }
    /**
     * Stops the spinner without a failed or succeeded status
     */
    stop(options) {
        const currentOptions = spinnies.pick(this.name);
        if (!currentOptions) {
            return;
        }
        spinnies.update(this.name, Object.assign(Object.assign(Object.assign({}, currentOptions), options), { status: "stopped" }));
    }
    /**
     * Stops the spinner and sets its status to succeeded.
     */
    succeed(text) {
        const options = spinnies.pick(this.name);
        if (!options) {
            return;
        }
        spinnies.succeed(this.name, Object.assign(Object.assign({}, options), { text }));
    }
    /**
     * Stops the spinner and sets its status to fail.
     */
    fail(text) {
        const options = spinnies.pick(this.name);
        if (!options) {
            return;
        }
        spinnies.fail(this.name, Object.assign(Object.assign({}, options), { text }));
    }
    /**
     * @returns string the spinner prefix used on success
     */
    static get succeedPrefix() {
        return spinnies.options.succeedPrefix;
    }
    /**
     * Updates the spinner success decoration. Updates apply to all spinning
     * spinners, and do not apply to spinners that have already stopped.
     */
    static set succeedPrefix(value) {
        spinnies.options.succeedPrefix = value;
    }
    /**
     * @returns string the spinner prefix used on failure
     */
    static get failPrefix() {
        return spinnies.options.failPrefix;
    }
    /**
     * Updates the spinner fail decoration. Updates apply to all spinning
     * spinners, and do not apply to spinners that have already stopped.
     */
    static set failPrefix(value) {
        spinnies.options.failPrefix = value;
    }
    /**
     * @returns string the text currently displayed by this spinner, without the
     * spinner decoration
     */
    get text() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.text;
    }
    /**
     * Updates the text displayed by this spinner
     */
    set text(value) {
        this._mutateOptions("text", value);
    }
    /**
     * @returns string the `chalk` color of this spinner's text
     */
    get color() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.color;
    }
    /**
     * updates the `chalk` color of this spinner's text
     */
    set color(value) {
        this._mutateOptions("color", value);
    }
    /**
     * @returns string the `chalk` color of this spinner decoration
     */
    get spinnerColor() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.spinnerColor;
    }
    /**
     * updates the `chalk` color of this spinner's decoration
     */
    set spinnerColor(value) {
        this._mutateOptions("spinnerColor", value);
    }
    /**
     * @returns string the `chalk` color of this spinner text on success (note: on
     * success, the spinner decoration is always green)
     */
    get succeedColor() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.succeedColor;
    }
    /**
     * Updates the `chalk` color of this spinner's text on success
     */
    set succeedColor(value) {
        this._mutateOptions("succeedColor", value);
    }
    /**
     * @returns string the `chalk` color of this spinner text on failure (note: on
     * failure, the spinner decoration is always red)
     */
    get failColor() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.failColor;
    }
    /**
     * Updates the `chalk` color of this spinner's text on failure
     */
    set failColor(value) {
        this._mutateOptions("failColor", value);
    }
    /**
     * @returns boolean `true` when the spinner is active and spinning, otherwise
     * `false`
     */
    get isSpinning() {
        const options = spinnies.pick(this.name);
        if (!options) {
            return false;
        }
        return options.status === "spinning";
    }
    _mutateOptions(key, value) {
        const options = spinnies.pick(this.name);
        if (!options) {
            return;
        }
        options[key] = value;
        spinnies.update(this.name, options);
    }
}
exports.Spinner = Spinner;
//# sourceMappingURL=spinner.js.map