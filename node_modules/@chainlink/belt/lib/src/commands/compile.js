"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
class Compile extends command_1.Command {
    async run() {
        const { flags, args, argv } = this.parse(Compile);
        if (argv.length === 0) {
            this._help();
        }
        try {
            const config = await Promise.resolve().then(() => __importStar(require('../services/config')));
            const conf = config.load(flags.config);
            switch (args.compiler) {
                case 'all':
                    return await this.compileAll('solc', conf);
                case 'all-ovm':
                    return await this.compileAll('solc-ovm', conf);
                default:
                    return await this.compile(args.compiler, conf);
            }
        }
        catch (e) {
            this.error(e);
        }
    }
    async getCompiler(name) {
        return await Promise.resolve().then(() => __importStar(require(`../services/compilers/${name}`)));
    }
    async compile(compilerName, conf) {
        const compiler = await this.getCompiler(compilerName);
        await compiler.compileAll(conf);
    }
    async compileAll(compilerName, conf) {
        const compilers = await Promise.resolve().then(() => __importStar(require('../services/compilers')));
        await this.compile(compilerName, conf);
        await Promise.all([
            compilers.truffle.compileAll(conf),
            compilers.ethers.compileAll(conf),
        ]);
    }
}
exports.default = Compile;
Compile.description = 'Run various compilers and/or codegenners that target solidity smart contracts.';
Compile.examples = [
    `$ belt compile all

Creating directory at abi/v0.4...
Creating directory at abi/v0.5...
Creating directory at abi/v0.6...
Compiling 35 contracts...
...
...
Aggregator artifact saved!
AggregatorProxy artifact saved!
Chainlink artifact saved!
...`,
];
Compile.flags = {
    help: command_1.flags.help({ char: 'h' }),
    config: command_1.flags.string({
        char: 'c',
        default: 'app.config.json',
        description: 'Location of the configuration file',
    }),
};
Compile.args = [
    {
        name: 'compiler',
        description: 'Compile solidity smart contracts and output their artifacts',
        options: ['solc', 'solc-ovm', 'ethers', 'truffle', 'all', 'all-ovm'],
    },
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tYW5kcy9jb21waWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDRDQUErQztBQUsvQyxNQUFxQixPQUFRLFNBQVEsaUJBQU87SUFxQzFDLEtBQUssQ0FBQyxHQUFHO1FBQ1AsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQTtRQUNqRCxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQTtTQUNiO1FBRUQsSUFBSTtZQUNGLE1BQU0sTUFBTSxHQUFHLHdEQUFhLG9CQUFvQixHQUFDLENBQUE7WUFDakQsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUE7WUFFdEMsUUFBUSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNyQixLQUFLLEtBQUs7b0JBQ1IsT0FBTyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFBO2dCQUM1QyxLQUFLLFNBQVM7b0JBQ1osT0FBTyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFBO2dCQUNoRDtvQkFDRSxPQUFPLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFBO2FBQ2pEO1NBQ0Y7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUE7U0FDZDtJQUNILENBQUM7SUFFTyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQVk7UUFDcEMsT0FBTyx3REFBYSx5QkFBeUIsSUFBSSxFQUFFLEdBQUMsQ0FBQTtJQUN0RCxDQUFDO0lBRU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxZQUFvQixFQUFFLElBQVM7UUFDbkQsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFBO1FBQ3JELE1BQU0sUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUNqQyxDQUFDO0lBRU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxZQUFvQixFQUFFLElBQVM7UUFDdEQsTUFBTSxTQUFTLEdBQUcsd0RBQWEsdUJBQXVCLEdBQUMsQ0FBQTtRQUV2RCxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFBO1FBQ3RDLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQztZQUNoQixTQUFTLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7WUFDbEMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO1NBQ2xDLENBQUMsQ0FBQTtJQUNKLENBQUM7O0FBN0VILDBCQThFQztBQTdFUSxtQkFBVyxHQUNoQixnRkFBZ0YsQ0FBQTtBQUUzRSxnQkFBUSxHQUFHO0lBQ2hCOzs7Ozs7Ozs7OztJQVdBO0NBQ0QsQ0FBQTtBQUVNLGFBQUssR0FBRztJQUNiLElBQUksRUFBRSxlQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQy9CLE1BQU0sRUFBRSxlQUFLLENBQUMsTUFBTSxDQUFDO1FBQ25CLElBQUksRUFBRSxHQUFHO1FBQ1QsT0FBTyxFQUFFLGlCQUFpQjtRQUMxQixXQUFXLEVBQUUsb0NBQW9DO0tBQ2xELENBQUM7Q0FDSCxDQUFBO0FBRU0sWUFBSSxHQUF1QjtJQUNoQztRQUNFLElBQUksRUFBRSxVQUFVO1FBQ2hCLFdBQVcsRUFDVCw2REFBNkQ7UUFDL0QsT0FBTyxFQUFFLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLENBQUM7S0FDckU7Q0FDRixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbWFuZCwgZmxhZ3MgfSBmcm9tICdAb2NsaWYvY29tbWFuZCdcbmltcG9ydCAqIGFzIFBhcnNlciBmcm9tICdAb2NsaWYvcGFyc2VyJ1xuaW1wb3J0IHsgQXBwIH0gZnJvbSAnLi4vc2VydmljZXMvY29uZmlnJ1xuXG50eXBlIENvbXBpbGVycyA9IHR5cGVvZiBpbXBvcnQoJy4uL3NlcnZpY2VzL2NvbXBpbGVycycpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21waWxlIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBkZXNjcmlwdGlvbiA9XG4gICAgJ1J1biB2YXJpb3VzIGNvbXBpbGVycyBhbmQvb3IgY29kZWdlbm5lcnMgdGhhdCB0YXJnZXQgc29saWRpdHkgc21hcnQgY29udHJhY3RzLidcblxuICBzdGF0aWMgZXhhbXBsZXMgPSBbXG4gICAgYCQgYmVsdCBjb21waWxlIGFsbFxuXG5DcmVhdGluZyBkaXJlY3RvcnkgYXQgYWJpL3YwLjQuLi5cbkNyZWF0aW5nIGRpcmVjdG9yeSBhdCBhYmkvdjAuNS4uLlxuQ3JlYXRpbmcgZGlyZWN0b3J5IGF0IGFiaS92MC42Li4uXG5Db21waWxpbmcgMzUgY29udHJhY3RzLi4uXG4uLi5cbi4uLlxuQWdncmVnYXRvciBhcnRpZmFjdCBzYXZlZCFcbkFnZ3JlZ2F0b3JQcm94eSBhcnRpZmFjdCBzYXZlZCFcbkNoYWlubGluayBhcnRpZmFjdCBzYXZlZCFcbi4uLmAsXG4gIF1cblxuICBzdGF0aWMgZmxhZ3MgPSB7XG4gICAgaGVscDogZmxhZ3MuaGVscCh7IGNoYXI6ICdoJyB9KSxcbiAgICBjb25maWc6IGZsYWdzLnN0cmluZyh7XG4gICAgICBjaGFyOiAnYycsXG4gICAgICBkZWZhdWx0OiAnYXBwLmNvbmZpZy5qc29uJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnTG9jYXRpb24gb2YgdGhlIGNvbmZpZ3VyYXRpb24gZmlsZScsXG4gICAgfSksXG4gIH1cblxuICBzdGF0aWMgYXJnczogUGFyc2VyLmFyZ3MuSUFyZ1tdID0gW1xuICAgIHtcbiAgICAgIG5hbWU6ICdjb21waWxlcicsXG4gICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgJ0NvbXBpbGUgc29saWRpdHkgc21hcnQgY29udHJhY3RzIGFuZCBvdXRwdXQgdGhlaXIgYXJ0aWZhY3RzJyxcbiAgICAgIG9wdGlvbnM6IFsnc29sYycsICdzb2xjLW92bScsICdldGhlcnMnLCAndHJ1ZmZsZScsICdhbGwnLCAnYWxsLW92bSddLFxuICAgIH0sXG4gIF1cblxuICBhc3luYyBydW4oKSB7XG4gICAgY29uc3QgeyBmbGFncywgYXJncywgYXJndiB9ID0gdGhpcy5wYXJzZShDb21waWxlKVxuICAgIGlmIChhcmd2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5faGVscCgpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IGltcG9ydCgnLi4vc2VydmljZXMvY29uZmlnJylcbiAgICAgIGNvbnN0IGNvbmYgPSBjb25maWcubG9hZChmbGFncy5jb25maWcpXG5cbiAgICAgIHN3aXRjaCAoYXJncy5jb21waWxlcikge1xuICAgICAgICBjYXNlICdhbGwnOlxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbXBpbGVBbGwoJ3NvbGMnLCBjb25mKVxuICAgICAgICBjYXNlICdhbGwtb3ZtJzpcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb21waWxlQWxsKCdzb2xjLW92bScsIGNvbmYpXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29tcGlsZShhcmdzLmNvbXBpbGVyLCBjb25mKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZXJyb3IoZSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldENvbXBpbGVyKG5hbWU6IHN0cmluZyk6IFByb21pc2U8Q29tcGlsZXJzW2tleW9mIENvbXBpbGVyc10+IHtcbiAgICByZXR1cm4gYXdhaXQgaW1wb3J0KGAuLi9zZXJ2aWNlcy9jb21waWxlcnMvJHtuYW1lfWApXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNvbXBpbGUoY29tcGlsZXJOYW1lOiBzdHJpbmcsIGNvbmY6IEFwcCkge1xuICAgIGNvbnN0IGNvbXBpbGVyID0gYXdhaXQgdGhpcy5nZXRDb21waWxlcihjb21waWxlck5hbWUpXG4gICAgYXdhaXQgY29tcGlsZXIuY29tcGlsZUFsbChjb25mKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjb21waWxlQWxsKGNvbXBpbGVyTmFtZTogc3RyaW5nLCBjb25mOiBBcHApIHtcbiAgICBjb25zdCBjb21waWxlcnMgPSBhd2FpdCBpbXBvcnQoJy4uL3NlcnZpY2VzL2NvbXBpbGVycycpXG5cbiAgICBhd2FpdCB0aGlzLmNvbXBpbGUoY29tcGlsZXJOYW1lLCBjb25mKVxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGNvbXBpbGVycy50cnVmZmxlLmNvbXBpbGVBbGwoY29uZiksXG4gICAgICBjb21waWxlcnMuZXRoZXJzLmNvbXBpbGVBbGwoY29uZiksXG4gICAgXSlcbiAgfVxufVxuIl19